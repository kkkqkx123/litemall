# 需求4：订单统计功能拓展完善方案

## 需求描述
在原订单统计功能基础上，完善时间维度选择逻辑，支持指定具体年份、季度、月份、日，并按商品类别统计。当后续维度不选择时默认全选，日期选择不考虑每月对应天数（最大可选31），查询时才检查有效性，超出月份天数后抛异常。以简洁的表格形式展示订单数量、订单金额等统计信息。

## 技术方案

### 前端实现

1. **时间维度选择器组件**
```javascript
// 时间维度选择器组件
<template>
  <div class="time-selector">
    <!-- 年份选择 -->
    <el-select v-model="selectedYear" placeholder="选择年份" @change="handleYearChange">
      <el-option 
        v-for="year in availableYears" 
        :key="year" 
        :label="year + '年'" 
        :value="year">
      </el-option>
    </el-select>
    
    <!-- 季度选择 -->
    <el-select v-model="selectedQuarter" placeholder="选择季度" clearable @change="handleQuarterChange">
      <el-option label="全年" :value="null"></el-option>
      <el-option label="第一季度" :value="1"></el-option>
      <el-option label="第二季度" :value="2"></el-option>
      <el-option label="第三季度" :value="3"></el-option>
      <el-option label="第四季度" :value="4"></el-option>
    </el-select>
    
    <!-- 月份选择 -->
    <el-select v-model="selectedMonth" placeholder="选择月份" clearable @change="handleMonthChange" 
               :disabled="!selectedYear">
      <el-option label="全季度/全年" :value="null"></el-option>
      <el-option 
        v-for="month in availableMonths" 
        :key="month" 
        :label="month + '月'" 
        :value="month">
      </el-option>
    </el-select>
    
    <!-- 日期选择 -->
    <el-select v-model="selectedDay" placeholder="选择日期" clearable :disabled="!selectedMonth">
      <el-option label="全月" :value="null"></el-option>
      <el-option 
        v-for="day in 31" 
        :key="day" 
        :label="day + '日'" 
        :value="day">
      </el-option>
    </el-select>
  </div>
</template>

<script>
export default {
  data() {
    return {
      selectedYear: null,
      selectedQuarter: null,
      selectedMonth: null,
      selectedDay: null,
      availableYears: [], // 生成可选年份范围
      availableMonths: [] // 根据季度动态生成
    }
  },
  methods: {
    handleYearChange() {
      this.selectedQuarter = null;
      this.selectedMonth = null;
      this.selectedDay = null;
    },
    handleQuarterChange() {
      this.selectedMonth = null;
      this.selectedDay = null;
      this.updateAvailableMonths();
    },
    handleMonthChange() {
      this.selectedDay = null;
    },
    updateAvailableMonths() {
      // 根据选择的季度更新可选月份
      if (this.selectedQuarter) {
        const quarterMonths = {
          1: [1, 2, 3],
          2: [4, 5, 6], 
          3: [7, 8, 9],
          4: [10, 11, 12]
        };
        this.availableMonths = quarterMonths[this.selectedQuarter];
      } else {
        this.availableMonths = Array.from({length: 12}, (_, i) => i + 1);
      }
    },
    getTimeRange() {
      // 构建时间范围参数
      return {
        year: this.selectedYear,
        quarter: this.selectedQuarter,
        month: this.selectedMonth,
        day: this.selectedDay
      };
    }
  }
}
</script>
```

2. **商品类别选择器**
```javascript
// 商品类别选择器
<el-select v-model="categoryId" placeholder="选择商品类别" clearable>
  <el-option label="全部类别" :value="null"></el-option>
  <el-option 
    v-for="category in categories" 
    :key="category.id" 
    :label="category.name" 
    :value="category.id">
  </el-option>
</el-select>
```

3. **统计信息表格组件**
```javascript
// 使用Element UI的表格组件
<template>
  <div class="statistics-container">
    <!-- 统计汇总信息 -->
    <div class="summary-info">
      <div class="summary-item">
        <span class="label">总订单数：</span>
        <span class="value">{{ summary.totalCount }}</span>
      </div>
      <div class="summary-item">
        <span class="label">总金额：</span>
        <span class="value">¥{{ summary.totalAmount }}</span>
      </div>
      <div class="summary-item">
        <span class="label">平均金额：</span>
        <span class="value">¥{{ summary.avgAmount }}</span>
      </div>
    </div>
    
    <!-- 统计详情表格 -->
    <el-table :data="statisticsData" style="width: 100%" v-loading="loading">
      <el-table-column prop="timeLabel" label="时间"></el-table-column>
      <el-table-column prop="orderCount" label="订单数量"></el-table-column>
      <el-table-column prop="orderAmount" label="订单金额">
        <template slot-scope="scope">
          ¥{{ scope.row.orderAmount }}
        </template>
      </el-table-column>
      <el-table-column prop="avgAmount" label="平均金额">
        <template slot-scope="scope">
          ¥{{ scope.row.avgAmount }}
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script>
export default {
  data() {
    return {
      loading: false,
      summary: {
        totalCount: 0,
        totalAmount: 0,
        avgAmount: 0
      },
      statisticsData: []
    }
  },
  methods: {
    async getStatistics() {
      this.loading = true;
      const timeRange = this.getTimeRange();
      const params = {
        ...timeRange,
        categoryId: this.categoryId
      };
      
      try {
        const response = await this.$api.getOrderStatistics(params);
        this.summary = response.data.summary;
        this.statisticsData = response.data.details;
      } catch (error) {
        if (error.response && error.response.data.errno === 502) {
          this.$message.error('选择的日期超出当月天数范围，请重新选择');
        } else {
          this.$message.error('获取统计数据失败');
        }
      } finally {
        this.loading = false;
      }
    }
  }
}
</script>

<style scoped>
.statistics-container {
  margin-top: 20px;
}

.summary-info {
  display: flex;
  justify-content: space-around;
  margin-bottom: 20px;
  padding: 15px;
  background-color: #f5f7fa;
  border-radius: 4px;
}

.summary-item {
  text-align: center;
}

.summary-item .label {
  display: block;
  font-size: 14px;
  color: #909399;
  margin-bottom: 5px;
}

.summary-item .value {
  display: block;
  font-size: 20px;
  font-weight: bold;
  color: #303133;
}
</style>
```

### 后端实现

1. **统计API接口完善**
```java
@RestController
@RequestMapping("/admin/statistics")
public class AdminStatisticsController {
    
    @GetMapping("/order")
    public Object getOrderStatistics(
            @RequestParam Integer year,
            @RequestParam(required = false) Integer quarter,
            @RequestParam(required = false) Integer month,
            @RequestParam(required = false) Integer day,
            @RequestParam(required = false) Integer categoryId) {
        
        // 参数验证
        if (year == null || year < 2000 || year > 2100) {
            return ResponseUtil.fail(401, "年份参数无效");
        }
        
        // 验证日期有效性
        try {
            validateDateParams(year, quarter, month, day);
        } catch (IllegalArgumentException e) {
            return ResponseUtil.fail(502, e.getMessage());
        }
        
        // 构建时间范围
        LocalDateTime[] timeRange = buildTimeRange(year, quarter, month, day);
        
        // 获取统计数据
        Map<String, Object> result = orderService.getStatistics(
            timeRange[0], timeRange[1], categoryId);
        
        return ResponseUtil.ok(result);
    }
    
    private void validateDateParams(Integer year, Integer quarter, Integer month, Integer day) {
        if (quarter != null && (quarter < 1 || quarter > 4)) {
            throw new IllegalArgumentException("季度参数必须在1-4之间");
        }
        
        if (month != null && (month < 1 || month > 12)) {
            throw new IllegalArgumentException("月份参数必须在1-12之间");
        }
        
        if (day != null) {
            if (day < 1 || day > 31) {
                throw new IllegalArgumentException("日期参数必须在1-31之间");
            }
            
            // 检查日期是否有效
            if (month != null) {
                YearMonth yearMonth = YearMonth.of(year, month);
                if (day > yearMonth.lengthOfMonth()) {
                    throw new IllegalArgumentException(
                        String.format("%d年%d月只有%d天", year, month, yearMonth.lengthOfMonth()));
                }
            }
        }
    }
    
    private LocalDateTime[] buildTimeRange(Integer year, Integer quarter, Integer month, Integer day) {
        LocalDateTime startTime;
        LocalDateTime endTime;
        
        if (day != null && month != null) {
            // 具体某一天
            LocalDate date = LocalDate.of(year, month, day);
            startTime = date.atStartOfDay();
            endTime = date.atTime(LocalTime.MAX);
        } else if (month != null) {
            // 某个月
            YearMonth yearMonth = YearMonth.of(year, month);
            startTime = yearMonth.atDay(1).atStartOfDay();
            endTime = yearMonth.atEndOfMonth().atTime(LocalTime.MAX);
        } else if (quarter != null) {
            // 某个季度
            Month firstMonth = getQuarterFirstMonth(quarter);
            startTime = LocalDate.of(year, firstMonth, 1).atStartOfDay();
            Month lastMonth = getQuarterLastMonth(quarter);
            YearMonth lastYearMonth = YearMonth.of(year, lastMonth);
            endTime = lastYearMonth.atEndOfMonth().atTime(LocalTime.MAX);
        } else {
            // 全年
            startTime = LocalDate.of(year, 1, 1).atStartOfDay();
            endTime = LocalDate.of(year, 12, 31).atTime(LocalTime.MAX);
        }
        
        return new LocalDateTime[]{startTime, endTime};
    }
    
    private Month getQuarterFirstMonth(int quarter) {
        switch (quarter) {
            case 1: return Month.JANUARY;
            case 2: return Month.APRIL;
            case 3: return Month.JULY;
            case 4: return Month.OCTOBER;
            default: throw new IllegalArgumentException("无效季度");
        }
    }
    
    private Month getQuarterLastMonth(int quarter) {
        switch (quarter) {
            case 1: return Month.MARCH;
            case 2: return Month.JUNE;
            case 3: return Month.SEPTEMBER;
            case 4: return Month.DECEMBER;
            default: throw new IllegalArgumentException("无效季度");
        }
    }
}
```

2. **Service层统计逻辑完善**
```java
@Service
public class OrderStatisticsService {
    
    @Resource
    private LitemallOrderMapper orderMapper;
    
    @Resource
    private LitemallOrderGoodsMapper orderGoodsMapper;
    
    @Resource
    private LitemallGoodsMapper goodsMapper;
    
    public Map<String, Object> getStatistics(LocalDateTime startTime, LocalDateTime endTime, Integer categoryId) {
        Map<String, Object> result = new HashMap<>();
        
        // 构建基础查询条件
        LitemallOrderExample example = new LitemallOrderExample();
        LitemallOrderExample.Criteria criteria = example.createCriteria();
        criteria.andAddTimeBetween(startTime, endTime);
        
        // 如果指定了商品类别，需要关联查询
        if (categoryId != null) {
            // 获取该类别下的所有商品ID
            LitemallGoodsExample goodsExample = new LitemallGoodsExample();
            goodsExample.createCriteria().andCategoryIdEqualTo(categoryId);
            List<Integer> goodsIds = goodsMapper.selectByExample(goodsExample)
                .stream().map(LitemallGoods::getId).collect(Collectors.toList());
            
            if (goodsIds.isEmpty()) {
                // 该类别下没有商品，返回空结果
                result.put("totalCount", 0);
                result.put("totalAmount", BigDecimal.ZERO);
                result.put("avgAmount", BigDecimal.ZERO);
                result.put("details", Collections.emptyList());
                return result;
            }
            
            // 获取包含这些商品的订单ID
            LitemallOrderGoodsExample orderGoodsExample = new LitemallOrderGoodsExample();
            orderGoodsExample.createCriteria().andGoodsIdIn(goodsIds);
            List<Integer> orderIds = orderGoodsMapper.selectByExample(orderGoodsExample)
                .stream().map(LitemallOrderGoods::getOrderId).distinct().collect(Collectors.toList());
            
            if (orderIds.isEmpty()) {
                // 没有找到相关订单
                result.put("totalCount", 0);
                result.put("totalAmount", BigDecimal.ZERO);
                result.put("avgAmount", BigDecimal.ZERO);
                result.put("details", Collections.emptyList());
                return result;
            }
            
            criteria.andIdIn(orderIds);
        }
        
        // 执行统计查询
        List<StatisticsResult> statistics = orderMapper.selectStatisticsByTimeRange(example);
        
        // 计算总计
        long totalCount = statistics.stream().mapToLong(StatisticsResult::getOrderCount).sum();
        BigDecimal totalAmount = statistics.stream()
            .map(StatisticsResult::getOrderAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal avgAmount = totalCount > 0 ? totalAmount.divide(BigDecimal.valueOf(totalCount), 2, RoundingMode.HALF_UP) : BigDecimal.ZERO;
        
        result.put("totalCount", totalCount);
        result.put("totalAmount", totalAmount);
        result.put("avgAmount", avgAmount);
        result.put("details", statistics);
        
        return result;
    }
}
```

3. **Mapper SQL查询优化**
```xml
<!-- OrderMapper.xml -->
<resultMap id="StatisticsResultMap" type="org.linlinjava.litemall.core.domain.StatisticsResult">
    <result column="time_label" property="timeLabel" jdbcType="VARCHAR" />
    <result column="order_count" property="orderCount" jdbcType="BIGINT" />
    <result column="order_amount" property="orderAmount" jdbcType="DECIMAL" />
</resultMap>

<!-- 按时间范围统计订单 -->
<select id="selectStatisticsByTimeRange" resultMap="StatisticsResultMap">
    SELECT 
        <choose>
            <when test="startTime.toLocalDate().equals(endTime.toLocalDate())">
                HOUR(add_time) as time_label,
            </when>
            <when test="startTime.toLocalDate().getMonth().equals(endTime.toLocalDate().getMonth())">
                DATE(add_time) as time_label,
            </when>
            <when test="startTime.toLocalDate().getYear() == endTime.toLocalDate().getYear()">
                MONTH(add_time) as time_label,
            </when>
            <otherwise>
                YEAR(add_time) as time_label,
            </otherwise>
        </choose>
        COUNT(*) as order_count,
        SUM(actual_price) as order_amount
    FROM litemall_order
    <where>
        <if test="oredCriteria != null">
            <foreach collection="oredCriteria" item="criteria">
                <if test="criteria.valid">
                    ${criteria.condition}
                </if>
            </foreach>
        </if>
    </where>
    GROUP BY time_label
    ORDER BY time_label ASC
</select>
```

## 数据结构设计

### 返回数据结构
```javascript
{
  "errno": 0,
  "data": {
    "summary": {
      "totalCount": 150,
      "totalAmount": 75000.00,
      "avgAmount": 500.00
    },
    "details": [
      {
        "timeLabel": "2024-01-01",
        "orderCount": 10,
        "orderAmount": 5000.00,
        "avgAmount": 500.00
      },
      {
        "timeLabel": "2024-01-02", 
        "orderCount": 15,
        "orderAmount": 7500.00,
        "avgAmount": 500.00
      }
      // ... 更多数据
    ]
  }
}
```

### 错误码定义
- `errno: 401`: 参数无效（年份、季度、月份、日期范围错误）
- `errno: 502`: 日期超出当月天数范围

## 实施步骤

1. **前端开发** (6-8小时)
   - 实现时间维度选择器组件
   - 完善商品类别选择逻辑
   - 实现表格展示统计数据
   - 添加错误处理和用户提示

2. **后端开发** (6-8小时)
   - 完善参数验证逻辑
   - 实现时间范围构建算法
   - 优化统计查询SQL
   - 添加商品类别筛选逻辑

3. **测试验证** (3-4小时)
   - 测试各种时间维度组合
   - 验证日期有效性检查
   - 测试商品类别筛选功能
   - 性能测试和边界条件测试

## 性能优化建议

1. **数据库优化**
   - 在 `add_time` 字段上建立索引
   - 考虑按时间分区存储订单数据
   - 使用覆盖索引减少回表查询

2. **缓存策略**
   - 对常用统计结果进行缓存
   - 按时间维度和类别组合建立缓存键
   - 设置合理的缓存过期时间

3. **查询优化**
   - 限制单次查询时间范围（如最多一年）
   - 对大查询结果进行分页处理
   - 考虑使用物化视图预计算统计数据

## 注意事项

1. **用户体验**
   - 提供清晰的时间选择指引
   - 添加加载状态提示
   - 对无效日期给出明确提示
   - 确保表格数据清晰易读

2. **数据准确性**
   - 确保时间范围计算准确
   - 处理时区和夏令时问题
   - 验证商品类别筛选的正确性
   - 确保统计数据的精度

3. **系统稳定性**
   - 添加查询超时控制
   - 实现优雅的错误处理
   - 监控查询性能指标
   - 考虑大数据量时的表格渲染性能