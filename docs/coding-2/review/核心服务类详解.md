# 核心服务类详解

## 概述

LLM模块包含三个核心服务类：`LLMQAService`、`SessionManager`和`Qwen3Service`。这些服务类协同工作，实现了完整的商品问答功能。

## LLMQAService - 问答服务核心

### 类结构

```java
@Service
public class LLMQAService {
    
    @Autowired
    private Qwen3Service qwen3Service;
    
    @Autowired
    private SessionManager sessionManager;
    
    @Autowired
    private LLMOutputParser llmOutputParser;
    
    @Autowired
    private GoodsQueryService goodsQueryService;
    
    @Autowired
    private QueryIntentBuilder queryIntentBuilder;
    
    private static final Logger logger = LoggerFactory.getLogger(LLMQAService.class);
}
```

### 核心方法：handleGoodsQA

#### 方法签名

```java
public GoodsQAResponse handleGoodsQA(GoodsQARequest request)
```

#### 处理流程

```java
public GoodsQAResponse handleGoodsQA(GoodsQARequest request) {
    logger.info("开始处理商品问答请求 - 用户ID: {}, 问题: {}", 
        request.getUserId(), request.getQuestion());
    
    try {
        // 1. 参数验证
        validateRequest(request);
        
        // 2. 获取或创建会话
        Session session = getOrCreateSession(request);
        
        // 3. 构建提示词
        String prompt = buildPrompt(request, session);
        
        // 4. 调用LLM
        String llmResponse = qwen3Service.callLLM(prompt);
        
        // 5. 解析LLM输出
        QueryIntent queryIntent = llmOutputParser.parse(llmResponse);
        
        // 6. 执行数据库查询
        Object queryResult = executeQuery(queryIntent);
        
        // 7. 生成自然语言回答
        String naturalAnswer = generateNaturalAnswer(llmResponse, queryResult);
        
        // 8. 构建响应
        return buildResponse(request, naturalAnswer, queryResult, queryIntent);
        
    } catch (Exception e) {
        logger.error("处理商品问答失败: {}", e.getMessage(), e);
        return GoodsQAResponse.error("处理请求失败，请稍后重试");
    }
}
```

#### 详细步骤分析

##### 1. 参数验证

```java
private void validateRequest(GoodsQARequest request) {
    if (request == null) {
        throw new IllegalArgumentException("请求对象不能为空");
    }
    
    if (request.getQuestion() == null || request.getQuestion().trim().isEmpty()) {
        throw new IllegalArgumentException("问题不能为空");
    }
    
    if (request.getUserId() == null) {
        throw new IllegalArgumentException("用户ID不能为空");
    }
    
    // 问题长度限制
    if (request.getQuestion().length() > 500) {
        throw new IllegalArgumentException("问题长度不能超过500字符");
    }
}
```

##### 2. 会话管理

```java
private Session getOrCreateSession(GoodsQARequest request) {
    String sessionId = request.getSessionId();
    
    if (sessionId != null && !sessionId.trim().isEmpty()) {
        // 尝试获取现有会话
        Session session = sessionManager.getSession(sessionId);
        if (session != null && !session.isExpired()) {
            logger.debug("使用现有会话: {}", sessionId);
            return session;
        }
        logger.debug("会话不存在或已过期，创建新会话");
    }
    
    // 创建新会话
    return sessionManager.createSession(request.getUserId());
}
```

##### 3. 提示词构建

```java
private String buildPrompt(GoodsQARequest request, Session session) {
    StringBuilder prompt = new StringBuilder();
    
    // 系统提示词
    prompt.append("你是一个智能商品问答助手。");
    prompt.append("请根据用户的问题，生成相应的查询意图。");
    prompt.append("返回格式必须是JSON，包含query_type和conditions字段。");
    prompt.append("\\n\\n");
    
    // 会话上下文
    if (!session.getHistory().isEmpty()) {
        prompt.append("历史对话：");
        for (ChatMessage message : session.getHistory()) {
            prompt.append("\\n").append(message.getRole()).append(": ").append(message.getContent());
        }
        prompt.append("\\n\\n");
    }
    
    // 当前问题
    prompt.append("用户问题：").append(request.getQuestion());
    prompt.append("\\n请生成查询意图：");
    
    return prompt.toString();
}
```

##### 4. 查询执行

```java
private Object executeQuery(QueryIntent queryIntent) {
    try {
        // 验证查询意图
        if (!queryIntentBuilder.validateQueryIntent(queryIntent)) {
            throw new RuntimeException("无效的查询意图");
        }
        
        // 执行查询
        if ("statistical".equals(queryIntent.getQueryType())) {
            return goodsQueryService.executeStatisticalQuery(queryIntent);
        } else {
            return goodsQueryService.executeQuery(queryIntent);
        }
        
    } catch (Exception e) {
        logger.error("执行查询失败: {}", e.getMessage(), e);
        throw new RuntimeException("查询执行失败", e);
    }
}
```

##### 5. 自然语言生成

```java
private String generateNaturalAnswer(String llmResponse, Object queryResult) {
    if (queryResult instanceof List) {
        List<Goods> goodsList = (List<Goods>) queryResult;
        
        if (goodsList.isEmpty()) {
            return "很抱歉，没有找到符合您要求的商品。";
        }
        
        StringBuilder answer = new StringBuilder();
        answer.append("为您找到").append(goodsList.size()).append("件商品：");
        answer.append("\\n");
        
        for (int i = 0; i < Math.min(5, goodsList.size()); i++) {
            Goods goods = goodsList.get(i);
            answer.append(i + 1).append(". ").append(goods.getName());
            answer.append(" - 价格：¥").append(goods.getRetailPrice());
            answer.append("\\n");
        }
        
        if (goodsList.size() > 5) {
            answer.append("... 还有").append(goodsList.size() - 5).append("件商品");
        }
        
        return answer.toString();
        
    } else if (queryResult instanceof Long) {
        return "共有" + queryResult + "件商品符合您的要求。";
        
    } else if (queryResult instanceof Map) {
        Map<String, Object> stats = (Map<String, Object>) queryResult;
        StringBuilder answer = new StringBuilder();
        answer.append("统计结果：");
        
        for (Map.Entry<String, Object> entry : stats.entrySet()) {
            answer.append("\\n").append(entry.getKey()).append(": ").append(entry.getValue());
        }
        
        return answer.toString();
    }
    
    return llmResponse;
}
```

## SessionManager - 会话管理器

### 类结构

```java
@Service
public class LLMSessionManager {
    
    private final Map<String, Session> sessions = new ConcurrentHashMap<>();
    
    @Value("${llm.session.timeout:1800}")
    private long sessionTimeout; // 默认30分钟
    
    @Value("${llm.session.max-history:10}")
    private int maxHistorySize; // 最大历史记录数
    
    private static final Logger logger = LoggerFactory.getLogger(LLMSessionManager.class);
}
```

### 会话创建

```java
public String createSession(Integer userId) {
    String sessionId = generateSessionId();
    Session session = new Session(sessionId, userId);
    sessions.put(sessionId, session);
    
    logger.debug("创建新会话：sessionId={}, userId={}", sessionId, userId);
    return sessionId;
}

private String generateSessionId() {
    return "session_" + sessionIdGenerator.incrementAndGet() + "_" + System.nanoTime();
}
```

### 会话获取与验证

```java
public Session getSession(String sessionId) {
    Session session = sessions.get(sessionId);
    
    if (session != null) {
        // 更新最后访问时间
        session.updateLastAccessTime();
        
        if (session.isExpired()) {
            logger.info("会话已过期 - 会话ID: {}", sessionId);
            sessions.remove(sessionId);
            return null;
        }
    }
    
    return session;
}
```

### 消息管理

```java
public void addMessage(String sessionId, String role, String content) {
    Session session = getSession(sessionId);
    if (session == null) {
        logger.warn("尝试向不存在的会话添加消息 - 会话ID: {}", sessionId);
        return;
    }
    
    ChatMessage message = new ChatMessage(role, content);
    session.addMessage(message);
    
    logger.debug("添加消息到会话 - 会话ID: {}, 角色: {}, 内容长度: {}", 
        sessionId, role, content.length());
}
```

### 会话清理

```java
@Scheduled(fixedDelay = 300000) // 每5分钟执行一次
public void cleanupExpiredSessions() {
    logger.info("开始清理过期会话");
    
    int expiredCount = 0;
    Iterator<Map.Entry<String, Session>> iterator = sessions.entrySet().iterator();
    
    while (iterator.hasNext()) {
        Map.Entry<String, Session> entry = iterator.next();
        Session session = entry.getValue();
        
        if (session.isExpired()) {
            iterator.remove();
            expiredCount++;
            logger.debug("清理过期会话 - 会话ID: {}", entry.getKey());
        }
    }
    
    logger.info("会话清理完成 - 清理数量: {}, 剩余会话: {}", 
        expiredCount, sessions.size());
}
```

## Qwen3Service - LLM服务调用

### 类结构

```java
@Service
public class Qwen3Service {
    
    @Value("${llm.qwen3.api-key:}")
    private String apiKey;
    
    @Value("${llm.qwen3.api-url:https://api.qwen3.com/v1/chat/completions}")
    private String apiUrl;
    
    @Value("${llm.qwen3.model:qwen3-72b}")
    private String model;
    
    @Value("${llm.qwen3.timeout:30000}")
    private int timeout;
    
    @Value("${llm.qwen3.max-retries:3}")
    private int maxRetries;
    
    @Value("${llm.qwen3.enable-mock:false}")
    private boolean enableMock;
    
    private static final Logger logger = LoggerFactory.getLogger(Qwen3Service.class);
}
```

### LLM调用方法

```java
public String callLLM(String prompt) {
    if (enableMock) {
        logger.info("使用模拟响应模式");
        return generateMockResponse(prompt);
    }
    
    // 构建请求
    JSONObject request = buildRequest(prompt);
    
    // 重试机制
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            logger.info("调用Qwen3 API - 第{}次尝试", attempt);
            return doCallLLM(request);
        } catch (Exception e) {
            logger.warn("第{}次调用失败: {}", attempt, e.getMessage());
            
            if (attempt == maxRetries) {
                logger.error("所有重试都失败");
                throw new LLMServiceException("LLM服务调用失败", e);
            }
            
            // 指数退避
            try {
                Thread.sleep(1000 * attempt);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    throw new RuntimeException("意外的错误");
}
```

### 实际API调用

```java
private String doCallLLM(JSONObject request) throws IOException {
    HttpURLConnection connection = null;
    
    try {
        URL url = new URL(apiUrl);
        connection = (HttpURLConnection) url.openConnection();
        
        // 设置连接属性
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/json");
        connection.setRequestProperty("Authorization", "Bearer " + apiKey);
        connection.setDoOutput(true);
        connection.setConnectTimeout(timeout);
        connection.setReadTimeout(timeout);
        
        // 发送请求
        try (OutputStream os = connection.getOutputStream()) {
            byte[] input = request.toString().getBytes(StandardCharsets.UTF_8);
            os.write(input, 0, input.length);
        }
        
        // 读取响应
        int responseCode = connection.getResponseCode();
        logger.info("API响应码: {}", responseCode);
        
        if (responseCode == HttpURLConnection.HTTP_OK) {
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) {
                
                StringBuilder response = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    response.append(line);
                }
                
                return parseResponse(response.toString());
            }
        } else {
            throw new IOException("API调用失败，响应码: " + responseCode);
        }
        
    } finally {
        if (connection != null) {
            connection.disconnect();
        }
    }
}
```

### 请求构建

```java
private JSONObject buildRequest(String prompt) {
    JSONObject request = new JSONObject();
    
    // 模型信息
    request.put("model", model);
    
    // 消息列表
    JSONArray messages = new JSONArray();
    
    // 系统消息
    JSONObject systemMessage = new JSONObject();
    systemMessage.put("role", "system");
    systemMessage.put("content", "你是一个智能商品问答助手，请根据用户问题生成查询意图。");
    messages.put(systemMessage);
    
    // 用户消息
    JSONObject userMessage = new JSONObject();
    userMessage.put("role", "user");
    userMessage.put("content", prompt);
    messages.put(userMessage);
    
    request.put("messages", messages);
    
    // 参数设置
    request.put("temperature", 0.1);  // 低温度，确保输出一致性
    request.put("max_tokens", 1000);
    request.put("response_format", "json");
    
    return request;
}
```

### 响应解析

```java
private String parseResponse(String response) throws JSONException {
    JSONObject jsonResponse = new JSONObject(response);
    
    // 检查错误
    if (jsonResponse.has("error")) {
        JSONObject error = jsonResponse.getJSONObject("error");
        String errorMessage = error.getString("message");
        throw new RuntimeException("API错误: " + errorMessage);
    }
    
    // 提取回复内容
    JSONArray choices = jsonResponse.getJSONArray("choices");
    if (choices.length() > 0) {
        JSONObject choice = choices.getJSONObject(0);
        JSONObject message = choice.getJSONObject("message");
        return message.getString("content");
    }
    
    throw new RuntimeException("API响应格式错误");
}
```

### 模拟响应

```java
private String generateMockResponse(String prompt) {
    logger.debug("生成模拟响应 - 提示词: {}", prompt);
    
    // 根据提示词内容生成模拟响应
    if (prompt.contains("价格") && (prompt.contains("100") || prompt.contains("500"))) {
        return """
            我来帮您查找价格在100到500之间的商品。
            ```json
            {
                "query_type": "price_range",
                "conditions": {
                    "min_price": 100,
                    "max_price": 500
                },
                "sort": "price ASC"
            }
            ```
            """;
    }
    
    if (prompt.contains("库存") || prompt.contains("现货")) {
        return """
            我来帮您查询库存充足的商品。
            ```json
            {
                "query_type": "stock_check",
                "conditions": {
                    "min_number": 10
                }
            }
            ```
            """;
    }
    
    // 默认响应
    return """
        我来帮您查找相关商品。
        ```json
        {
            "query_type": "keyword_search",
            "conditions": {
                "keyword": "热门商品"
            },
            "limit": 10
        }
        ```
        """;
}
```

## 服务间协作流程

### 完整调用链

```
用户请求
    ↓
LLMQAService.handleGoodsQA()
    ├── 参数验证
    ├── SessionManager.getOrCreateSession()
    ├── buildPrompt()
    ├── Qwen3Service.callLLM()
    │   ├── buildRequest()
    │   ├── doCallLLM()
    │   └── parseResponse()
    ├── LLMOutputParser.parse()
    │   ├── JSONExtractor.extractJSON()
    │   └── JSON解析
    ├── GoodsQueryService.executeQuery()
    │   ├── SQLBuilder.buildQuerySQL()
    │   ├── ParameterBinder.bindParameters()
    │   └── 数据库查询
    ├── generateNaturalAnswer()
    └── buildResponse()
```

### 异常处理链

```java
public class GlobalExceptionHandler {
    
    @ExceptionHandler(LLMServiceException.class)
    public ResponseEntity<GoodsQAResponse> handleLLMServiceException(LLMServiceException e) {
        logger.error("LLM服务异常: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
            .body(GoodsQAResponse.error("AI服务暂时不可用，请稍后重试"));
    }
    
    @ExceptionHandler(LLMOutputParseException.class)
    public ResponseEntity<GoodsQAResponse> handleParseException(LLMOutputParseException e) {
        logger.error("解析异常: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(GoodsQAResponse.error("无法解析您的请求，请重新表述"));
    }
    
    @ExceptionHandler(SQLException.class)
    public ResponseEntity<GoodsQAResponse> handleSQLException(SQLException e) {
        logger.error("数据库异常: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(GoodsQAResponse.error("数据查询失败，请稍后重试"));
    }
}
```

## 性能优化

### 缓存机制

```java
@Service
public class CacheService {
    
    private final Map<String, QueryIntent> queryIntentCache = new ConcurrentHashMap<>();
    private final Map<String, List<Goods>> goodsCache = new ConcurrentHashMap<>();
    
    public QueryIntent getCachedQueryIntent(String llmOutput) {
        String key = generateKey(llmOutput);
        return queryIntentCache.get(key);
    }
    
    public void cacheQueryIntent(String llmOutput, QueryIntent intent) {
        String key = generateKey(llmOutput);
        queryIntentCache.put(key, intent);
    }
    
    public List<Goods> getCachedGoods(String queryKey) {
        return goodsCache.get(queryKey);
    }
    
    public void cacheGoods(String queryKey, List<Goods> goods) {
        goodsCache.put(queryKey, goods);
    }
}
```

### 异步处理

```java
@Service
public class AsyncService {
    
    @Async
    public CompletableFuture<String> callLLMAsync(String prompt) {
        try {
            String response = qwen3Service.callLLM(prompt);
            return CompletableFuture.completedFuture(response);
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }
    
    @Async
    public CompletableFuture<List<Goods>> executeQueryAsync(QueryIntent intent) {
        try {
            List<Goods> result = goodsQueryService.executeQuery(intent);
            return CompletableFuture.completedFuture(result);
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }
}
```

## 监控和日志

### 性能监控

```java
@Component
public class PerformanceMonitor {
    
    private static final Logger logger = LoggerFactory.getLogger(PerformanceMonitor.class);
    
    public <T> T monitor(String operation, Supplier<T> supplier) {
        long startTime = System.currentTimeMillis();
        
        try {
            T result = supplier.get();
            long duration = System.currentTimeMillis() - startTime;
            
            logger.info("操作完成 - {}: {}ms", operation, duration);
            
            // 慢操作告警
            if (duration > 1000) {
                logger.warn("慢操作告警 - {}: {}ms", operation, duration);
            }
            
            return result;
            
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            logger.error("操作失败 - {}: {}ms, 错误: {}", operation, duration, e.getMessage());
            throw e;
        }
    }
}
```

### 业务指标监控

```java
@Component
public class BusinessMetrics {
    
    private final AtomicLong totalRequests = new AtomicLong(0);
    private final AtomicLong successfulRequests = new AtomicLong(0);
    private final AtomicLong failedRequests = new AtomicLong(0);
    
    public void recordRequest(boolean success) {
        totalRequests.incrementAndGet();
        if (success) {
            successfulRequests.incrementAndGet();
        } else {
            failedRequests.incrementAndGet();
        }
    }
    
    @Scheduled(fixedDelay = 60000)
    public void reportMetrics() {
        long total = totalRequests.get();
        long success = successfulRequests.get();
        long failed = failedRequests.get();
        
        double successRate = total > 0 ? (double) success / total * 100 : 0;
        
        logger.info("业务指标 - 总请求: {}, 成功: {}, 失败: {}, 成功率: {:.2f}%", 
            total, success, failed, successRate);
        
        // 重置计数器
        totalRequests.set(0);
        successfulRequests.set(0);
        failedRequests.set(0);
    }
}
```

## 配置管理

### 应用配置

```yaml
# application.yml
llm:
  session:
    timeout: 1800  # 会话超时时间（秒）
    max-history: 10  # 最大历史记录数
  
  qwen3:
    api-key: ${LLM_API_KEY:}  # API密钥
    api-url: https://api.qwen3.com/v1/chat/completions
    model: qwen3-72b
    timeout: 30000  # 超时时间（毫秒）
    max-retries: 3  # 最大重试次数
    enable-mock: false  # 是否启用模拟响应
  
  database:
    max-connections: 20  # 最大连接数
    query-timeout: 10000  # 查询超时时间（毫秒）
    cache-enabled: true  # 是否启用缓存
```

### 环境变量

```bash
# 生产环境配置
export LLM_API_KEY="your-api-key-here"
export LLM_SESSION_TIMEOUT="3600"
export LLM_MAX_RETRIES="5"
export LLM_ENABLE_MOCK="false"
```

## 测试策略

### 单元测试

```java
@SpringBootTest
public class LLMQAServiceTest {
    
    @Autowired
    private LLMQAService llmqaService;
    
    @Test
    public void testHandleGoodsQA() {
        GoodsQARequest request = new GoodsQARequest();
        request.setUserId("test-user");
        request.setQuestion("价格在100到500之间的商品有哪些？");
        
        GoodsQAResponse response = llmqaService.handleGoodsQA(request);
        
        assertNotNull(response);
        assertEquals(200, response.getCode());
        assertNotNull(response.getAnswer());
        assertNotNull(response.getSessionId());
    }
    
    @Test
    public void testInvalidRequest() {
        GoodsQARequest request = new GoodsQARequest();
        request.setUserId(null); // 无效的用户ID
        request.setQuestion("测试问题");
        
        assertThrows(IllegalArgumentException.class, () -> {
            llmqaService.handleGoodsQA(request);
        });
    }
}
```

### 集成测试

```java
@SpringBootTest
@TestPropertySource(properties = {
    "llm.qwen3.enable-mock=true",
    "llm.session.timeout=60"
})
public class LLMIntegrationTest {
    
    @Autowired
    private LLMQAService llmqaService;
    
    @Test
    public void testFullWorkflow() {
        // 1. 创建请求
        GoodsQARequest request = createTestRequest();
        
        // 2. 执行完整流程
        GoodsQAResponse response = llmqaService.handleGoodsQA(request);
        
        // 3. 验证响应
        assertSuccessfulResponse(response);
        
        // 4. 验证会话状态
        assertSessionCreated(response.getSessionId());
        
        // 5. 验证多轮对话
        testMultiTurnConversation(response.getSessionId());
    }
}
```

## 总结

三个核心服务类通过明确的职责分工和协作机制，实现了完整的商品问答功能：

1. **LLMQAService**：业务逻辑协调者，负责整个问答流程的编排
2. **SessionManager**：会话状态管理者，维护多轮对话的上下文
3. **Qwen3Service**：LLM服务调用者，提供可靠的AI能力接入

这种设计确保了系统的可维护性、可扩展性和可靠性。