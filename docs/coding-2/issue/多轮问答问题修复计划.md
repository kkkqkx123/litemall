# 多轮问答问题修复计划

## 问题分析

### 1. 会话管理问题
- **问题**：会话创建后无法正确获取，导致上下文传递失败
- **表现**：`getSessionContext()`返回空上下文，会话历史获取失败
- **根因**：`LLMSessionManager`的会话存储和获取逻辑存在缺陷

### 2. 查询意图验证失败
- **问题**：第二轮问答时查询意图验证过于严格
- **表现**：`查询意图验证失败`错误，无法处理上下文相关的推荐查询
- **根因**：`QueryIntentBuilder.validateQueryIntent()`对推荐类型查询的条件验证不合理

### 3. 上下文传递机制缺失
- **问题**：无法在多轮对话中保持和利用上下文信息
- **表现**：每轮问答都是独立的，无法基于前文进行推荐
- **根因**：`buildEnhancedPrompt()`方法中上下文信息未正确传递和使用

## 修复方案

### 阶段一：修复会话管理

#### 1.1 修改 LLMQAService.processQuestion()
```java
// 修改会话获取逻辑
private LLMContext getSessionContext(String sessionId) {
    try {
        // 确保会话存在
        LLMSession session = sessionManager.getSession(sessionId);
        if (session == null) {
            log.warn("会话不存在，创建新会话: {}", sessionId);
            session = sessionManager.createSession("default-user", sessionId);
        }
        
        // 构建上下文
        LLMContext context = new LLMContext();
        context.setSessionId(sessionId);
        context.setUserPreferences(session.getPreferences());
        context.setQueryCount(session.getMessageCount());
        
        // 添加上轮查询信息
        if (session.getLastMessage() != null) {
            context.setLastQuery(session.getLastMessage().getContent());
            context.setLastQueryType(determineQueryType(session.getLastMessage().getContent()));
        }
        
        return context;
    } catch (Exception e) {
        log.error("获取会话上下文失败: {}", sessionId, e);
        // 返回默认上下文而不是null
        LLMContext defaultContext = new LLMContext();
        defaultContext.setSessionId(sessionId);
        return defaultContext;
    }
}
```

#### 1.2 增强 LLMSessionManager
```java
// 添加获取最后消息的方法
public Message getLastMessage(String sessionId) {
    Session session = sessions.get(sessionId);
    if (session != null && !session.getMessages().isEmpty()) {
        return session.getMessages().get(session.getMessages().size() - 1);
    }
    return null;
}

// 添加获取用户偏好的方法
public Map<String, Object> getPreferences(String sessionId) {
    Session session = sessions.get(sessionId);
    if (session != null) {
        return session.getPreferences();
    }
    return new HashMap<>();
}

// 修改会话创建逻辑
public Session createSession(String userId, String sessionId) {
    Session session = new Session(sessionId, userId);
    sessions.put(sessionId, session);
    log.info("创建会话成功: userId={}, sessionId={}", userId, sessionId);
    return session;
}
```

### 阶段二：优化查询意图验证

#### 2.1 修改 QueryIntentBuilder.validateQueryIntent()
```java
public boolean validateQueryIntent(QueryIntent queryIntent) {
    if (queryIntent == null || queryIntent.getQueryType() == null) {
        return false;
    }
    
    switch (queryIntent.getQueryType()) {
        case KEYWORD_SEARCH:
            // 关键词搜索需要包含关键词
            return queryIntent.getConditions().containsKey("keyword") &&
                   !StringUtils.isEmpty(queryIntent.getConditions().get("keyword"));
                   
        case CATEGORY_FILTER:
            // 分类过滤需要包含分类
            return queryIntent.getConditions().containsKey("category");
            
        case PRICE_RANGE:
            // 价格范围需要包含价格条件
            return queryIntent.getConditions().containsKey("minPrice") ||
                   queryIntent.getConditions().containsKey("maxPrice");
                   
        case RECOMMENDATION:
            // 推荐查询可以没有特定条件，支持上下文推荐
            return true; // 允许空条件，支持"有哪些适合送礼的"这类查询
            
        default:
            return false;
    }
}
```

#### 2.2 增强推荐查询处理
```java
// 在 BasicRecommendationAgent 中添加上下文感知
public List<Goods> recommend(LLMQueryIntent queryIntent, LLMContext context) {
    // 如果查询条件为空但存在上下文，使用上下文信息
    if (queryIntent.getConditions().isEmpty() && context != null) {
        // 基于上轮查询进行推荐
        if (context.getLastQueryType() == LLMQueryIntent.QueryType.PRICE_RANGE) {
            // 保持价格范围，推荐相关商品
            Map<String, Object> conditions = new HashMap<>();
            conditions.putAll(context.getUserPreferences());
            queryIntent.setConditions(conditions);
        }
    }
    
    return executeRecommendation(queryIntent);
}
```

### 阶段三：增强上下文传递

#### 3.1 修改 buildEnhancedPrompt()
```java
private String buildEnhancedPrompt(String question, LLMContext context) {
    StringBuilder prompt = new StringBuilder();
    
    // 添加上下文信息
    if (context != null && context.getQueryCount() > 0) {
        prompt.append("会话信息：\n");
        prompt.append("- 已进行查询次数：").append(context.getQueryCount()).append("\n");
        
        if (context.getLastQuery() != null) {
            prompt.append("- 上轮查询：").append(context.getLastQuery()).append("\n");
        }
        
        if (!context.getUserPreferences().isEmpty()) {
            prompt.append("- 用户偏好：").append(context.getUserPreferences()).append("\n");
        }
        prompt.append("\n");
    }
    
    prompt.append("当前问题：").append(question).append("\n\n");
    prompt.append("分析要求：\n");
    prompt.append("1. 如果是商品推荐问题，请分析用户意图\n");
    prompt.append("2. 如果是后续问题，请结合上下文理解\n");
    prompt.append("3. 输出格式要求：{\"queryType\":\"类型\",\"conditions\":{条件}}\n");
    
    return prompt.toString();
}
```

#### 3.2 增强 LLMOutputParser
```java
// 添加上下文感知解析
public LLMQueryIntent parseOutputWithContext(String output, LLMContext context) {
    LLMQueryIntent intent = parseOutput(output);
    
    // 如果解析结果条件为空但有上下文，尝试上下文推理
    if (intent.getConditions().isEmpty() && context != null && context.getQueryCount() > 0) {
        // 基于上下文推断意图
        if (context.getLastQueryType() == LLMQueryIntent.QueryType.PRICE_RANGE) {
            intent.setQueryType(LLMQueryIntent.QueryType.RECOMMENDATION);
            // 继承上次的偏好设置
            intent.setConditions(new HashMap<>(context.getUserPreferences()));
        }
    }
    
    return intent;
}
```

## 测试验证计划

### 测试用例1：基础会话管理
```bash
# 创建会话并测试
POST /admin/llm/qa/session/test-session-1/create
# 预期：成功创建会话

# 获取会话历史
GET /admin/llm/qa/session/test-session-1/history
# 预期：返回空历史记录
```

### 测试用例2：多轮问答测试
```bash
# 第一轮：价格范围查询
POST /admin/llm/qa/ask
{
    "sessionId": "test-session-1",
    "question": "推荐一些100-200元的商品"
}
# 预期：返回5个100-200元的商品

# 第二轮：上下文相关推荐
POST /admin/llm/qa/ask
{
    "sessionId": "test-session-1", 
    "question": "那其中哪些比较适合送礼"
}
# 预期：基于上轮结果推荐适合送礼的商品
```

### 测试用例3：会话历史验证
```bash
# 查看完整会话历史
GET /admin/llm/qa/session/test-session-1/history
# 预期：显示两轮问答的完整记录
```

## 预期结果

1. **会话管理**：会话创建、获取、历史记录功能正常工作
2. **上下文传递**：多轮对话中能保持和利用上下文信息
3. **查询验证**：推荐查询不再因条件缺失而验证失败
4. **用户体验**：支持自然的多轮商品推荐对话

## 实施优先级

1. **高优先级**：修复会话管理和查询验证（阶段一、二）
2. **中优先级**：增强上下文传递机制（阶段三）
3. **低优先级**：优化推荐算法和用户体验

## 风险评估

- **低风险**：会话管理修复，影响范围有限
- **中风险**：查询验证逻辑修改，需要充分测试各种查询类型
- **高风险**：上下文传递机制，可能影响现有单轮查询功能