# 多轮对话实现详解

## 概述

多轮对话是LLM模块的核心功能之一，通过会话管理机制实现用户与AI助手的连续交互。本模块采用基于内存的会话存储方案，支持会话超时、上下文保持等关键特性。

## 核心组件

### SessionManager - 会话管理器

`SessionManager`是会话管理的核心类，负责会话的创建、存储、获取和清理。

#### 主要功能

```java
@Service
public class SessionManager {
    private final Map<String, Session> sessions = new ConcurrentHashMap<>();
    private static final long SESSION_TIMEOUT = 30 * 60 * 1000L; // 30分钟
    
    // 创建新会话
    public Session createSession(Integer userId)
    
    // 获取会话
    public Session getSession(String sessionId)
    
    // 更新会话访问时间
    public void updateSessionAccessTime(String sessionId)
    
    // 清理过期会话
    @Scheduled(fixedDelay = 300000) // 每5分钟清理一次
    public void cleanupExpiredSessions()
}
```

#### 会话存储结构

```java
public class Session {
    private String sessionId;                    // 会话唯一标识
    private List<ConversationTurn> conversationHistory;  // 对话历史
    private LocalDateTime lastAccessTime;       // 最后访问时间
    private Map<String, Object> attributes;     // 会话属性
    private Integer userId;                     // 用户ID
}

public class ConversationTurn {
    private String userMessage;     // 用户消息
    private String assistantMessage; // 助手回复
    private LocalDateTime timestamp; // 时间戳
}
```

### Session - 会话实体

会话实体包含完整的对话上下文信息：

#### 会话属性

- **sessionId**：基于UUID的会话标识符
- **conversationHistory**：保存完整的对话历史记录
- **lastAccessTime**：用于超时判断
- **attributes**：存储会话级别的自定义属性
- **userId**：关联用户（可选）

#### 会话生命周期

1. **创建**：`createSession()`生成新会话
2. **活跃**：每次访问更新`lastAccessTime`
3. **超时**：30分钟无访问自动清理
4. **清理**：定时任务删除过期会话

## 多轮对话流程

### 1. 请求处理入口

```java
@PostMapping("/goods/qa")
public GoodsQAResponse handleGoodsQA(@RequestBody GoodsQARequest request) {
    return llmqaService.handleGoodsQA(request);
}
```

### 2. 会话获取或创建

```java
public GoodsQAResponse handleGoodsQA(GoodsQARequest request) {
    String sessionId = request.getSessionId();
    Session session = null;
    
    if (sessionId != null) {
        session = sessionManager.getSession(sessionId);
    }
    
    if (session == null) {
        session = sessionManager.createSession(request.getUserId());
        sessionId = session.getSessionId();
    }
}
```

### 3. 上下文构建

```java
private String buildPromptWithContext(String userQuestion, Session session) {
    StringBuilder prompt = new StringBuilder();
    
    // 添加系统提示词
    prompt.append(SYSTEM_PROMPT).append("\\n\\n");
    
    // 添加对话历史
    List<ConversationTurn> history = session.getConversationHistory();
    if (!history.isEmpty()) {
        prompt.append("=== 对话历史 ===\\n");
        for (ConversationTurn turn : history) {
            prompt.append("用户: ").append(turn.getUserMessage()).append("\\n");
            prompt.append("助手: ").append(turn.getAssistantMessage()).append("\\n");
        }
        prompt.append("\\n");
    }
    
    // 添加当前问题
    prompt.append("=== 当前问题 ===\\n");
    prompt.append("用户: ").append(userQuestion).append("\\n");
    prompt.append("请回答用户的问题，并提供相应的商品查询。");
    
    return prompt.toString();
}
```

### 4. LLM调用和响应处理

```java
// 调用LLM服务
LLMResponse llmResponse = qwen3Service.callLLM(prompt);

// 解析LLM输出
QueryIntent queryIntent = llmOutputParser.parse(llmResponse.getContent());

// 执行查询
List<Map<String, Object>> queryResults = goodsQueryService.executeQuery(queryIntent);
```

### 5. 会话更新

```java
// 创建对话轮次
ConversationTurn turn = new ConversationTurn();
turn.setUserMessage(request.getQuestion());
turn.setAssistantMessage(generatedAnswer);
turn.setTimestamp(LocalDateTime.now());

// 添加到会话历史
session.getConversationHistory().add(turn);

// 限制历史记录长度（保持最近10轮对话）
if (session.getConversationHistory().size() > 10) {
    session.getConversationHistory().remove(0);
}

// 更新会话访问时间
sessionManager.updateSessionAccessTime(sessionId);
```

### 6. 响应构建

```java
GoodsQAResponse response = new GoodsQAResponse();
response.setCode(200);
response.setMessage("success");
response.setAnswer(generatedAnswer);
response.setGoods(convertToGoodsList(queryResults));
response.setSessionId(sessionId);
response.setQueryTime(System.currentTimeMillis() - startTime);

return response;
```

## 会话超时机制

### 定时清理任务

```java
@Scheduled(fixedDelay = 300000) // 每5分钟执行一次
public void cleanupExpiredSessions() {
    LocalDateTime now = LocalDateTime.now();
    Iterator<Map.Entry<String, Session>> iterator = sessions.entrySet().iterator();
    
    while (iterator.hasNext()) {
        Map.Entry<String, Session> entry = iterator.next();
        Session session = entry.getValue();
        
        // 检查是否超时
        if (session.getLastAccessTime().plusMinutes(30).isBefore(now)) {
            iterator.remove();
            logger.info("清理过期会话: {}", entry.getKey());
        }
    }
}
```

### 超时处理

当用户使用过期的`sessionId`时：

1. 检测到会话不存在或已过期
2. 自动创建新的会话
3. 返回新的`sessionId`给前端
4. 重新开始对话（无历史上下文）

## 上下文管理策略

### 对话历史限制

- **最大轮次**：保留最近10轮对话
- **历史清理**：超过限制时移除最早的对话
- **内存优化**：防止会话占用过多内存

### 上下文构建策略

```java
private String buildContext(Session session, String currentQuestion) {
    StringBuilder context = new StringBuilder();
    
    // 1. 系统提示词
    context.append(getSystemPrompt());
    
    // 2. 对话历史（如果有）
    if (hasRelevantHistory(session, currentQuestion)) {
        context.append("历史对话:\\n");
        context.append(formatConversationHistory(session));
    }
    
    // 3. 当前问题
    context.append("当前问题: ").append(currentQuestion);
    
    return context.toString();
}
```

### 相关性判断

```java
private boolean hasRelevantHistory(Session session, String currentQuestion) {
    // 简单实现：检查历史是否为空
    // 高级实现：可以基于语义相似度判断
    return !session.getConversationHistory().isEmpty();
}
```

## 错误处理和容错

### 会话相关异常

```java
public class SessionException extends RuntimeException {
    public SessionException(String message) {
        super(message);
    }
    
    public SessionException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 错误处理策略

1. **会话获取失败**：创建新会话
2. **会话超时**：创建新会话
3. **历史记录损坏**：清空历史重新开始
4. **内存不足**：清理最旧的会话

## 性能优化

### 内存管理

```java
// 会话数量限制
private static final int MAX_SESSIONS = 1000;

// 会话清理策略
private void ensureMemoryLimit() {
    if (sessions.size() > MAX_SESSIONS) {
        // 移除最旧的会话
        removeOldestSessions(sessions.size() - MAX_SESSIONS);
    }
}
```

### 并发优化

```java
// 使用ConcurrentHashMap支持高并发
private final Map<String, Session> sessions = new ConcurrentHashMap<>();

// 会话操作使用同步
public synchronized Session createSession(Integer userId) {
    // 创建会话逻辑
}
```

## 扩展性设计

### 自定义属性支持

```java
// 支持存储自定义会话属性
public void setSessionAttribute(String sessionId, String key, Object value) {
    Session session = getSession(sessionId);
    if (session != null) {
        session.getAttributes().put(key, value);
    }
}

public Object getSessionAttribute(String sessionId, String key) {
    Session session = getSession(sessionId);
    return session != null ? session.getAttributes().get(key) : null;
}
```

### 事件监听

```java
// 会话事件监听器
public interface SessionListener {
    void onSessionCreated(Session session);
    void onSessionExpired(Session session);
    void onSessionUpdated(Session session);
}
```

## 使用示例

### 基本使用

```java
// 第一次请求（无sessionId）
GoodsQARequest request1 = new GoodsQARequest();
request1.setQuestion("有什么便宜的手机？");

GoodsQAResponse response1 = llmqaService.handleGoodsQA(request1);
String sessionId = response1.getSessionId(); // 保存sessionId

// 后续请求（使用sessionId）
GoodsQARequest request2 = new GoodsQARequest();
request2.setQuestion("推荐其中性价比最高的");
request2.setSessionId(sessionId);

GoodsQAResponse response2 = llmqaService.handleGoodsQA(request2);
```

### 带用户标识

```java
GoodsQARequest request = new GoodsQARequest();
request.setQuestion("我的订单状态如何？");
request.setUserId(12345); // 用户ID

GoodsQAResponse response = llmqaService.handleGoodsQA(request);
```

## 总结

多轮对话实现通过会话管理机制，为用户提供了连续的交互体验。主要特点：

1. **自动会话管理**：无需手动管理会话生命周期
2. **上下文保持**：支持历史对话记录的维护和利用
3. **容错处理**：完善的错误处理和异常恢复机制
4. **性能优化**：内存管理和并发优化
5. **扩展性**：支持自定义属性和事件监听

该实现为商品问答场景提供了稳定可靠的多轮对话支持。