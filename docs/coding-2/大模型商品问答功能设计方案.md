# 基于ModelScope Qwen3-32B的商品问答功能设计方案（简化版）

## 1. 功能概述

在后台管理模块实现基于ModelScope Qwen3-32B模型的商品问答功能，管理员可以通过自然语言对话查询商品信息。采用结构化JSON输出，后端封装业务逻辑，避免直接SQL生成。

## 2. 系统架构设计

### 2.1 整体架构
```
┌─────────────────────────────────────────────────────────────┐
│                    前端展示层                                │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              商品问答页面                            │    │
│  │  ┌─────────────┐    ┌─────────────┐               │    │
│  │  │  对话界面    │    │  商品展示    │               │    │
│  │  │  Chat UI     │    │  Goods View  │               │    │
│  │  └─────────────┘    └─────────────┘               │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────┐
│                    API网关层                                 │
│  ┌─────────────────────────────────────────────────────┐    │
│  │         AdminGoodsQAController                      │    │
│  │  ┌─────────────┐    ┌─────────────┐               │    │
│  │  │ 问题解析    │    │  商品查询    │               │    │
│  │  │  Parse Q    │    │  DB Query   │               │    │
│  │  └─────────────┘    └─────────────┘               │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────┐
│                    服务层                                   │
│  ┌─────────────────────────────────────────────────────┐    │
│  │        GoodsQAService                               │    │
│  │  ┌─────────────┐    ┌─────────────┐               │    │
│  │  │ 意图识别    │    │  查询执行    │               │    │
│  │  │ Intent Rec  │    │  Execute    │               │    │
│  │  └─────────────┘    └─────────────┘               │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────┐
│                    大模型服务                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │        Qwen3-32B LLM Service                        │    │
│  │  ┌─────────────┐                                    │    │
│  │  │ JSON输出    │                                    │    │
│  │  │ Structured  │                                    │    │
│  │  └─────────────┘                                    │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 技术栈选择
- **后端**: Spring Boot + MyBatis + MySQL
- **前端**: Vue.js + Element UI  
- **大模型API**: ModelScope Qwen3-32B
- **通信**: HTTP RESTful API

## 3. 可查询数据范围分析

基于现有商品表结构，LLM可以查询以下数据：

### 3.1 商品基本信息表 (litemall_goods)
- **价格相关**: retail_price(零售价格)、counter_price(市场价格)
- **状态相关**: is_on_sale(是否上架)、is_hot(是否热销)、is_new(是否新品)
- **描述相关**: name(商品名称)、brief(商品简介)、keywords(关键词)
- **时间相关**: add_time(添加时间)、update_time(更新时间)
- **分类相关**: category_id(分类ID)、brand_id(品牌ID)

### 3.2 商品库存表 (litemall_goods_product)
- **库存相关**: number(库存数量)
- **规格相关**: specifications(规格值)、price(货品价格)

### 3.3 商品分类表 (litemall_category)
- **分类信息**: name(分类名称)、keywords(分类关键词)

### 3.4 可查询数据类型
1. **价格查询**: 价格范围、最高/最低价格、平均价格
2. **库存查询**: 库存数量、低库存商品、高库存商品
3. **状态查询**: 在售商品、热销商品、新品
4. **分类查询**: 按分类筛选商品、分类统计
5. **统计查询**: 商品总数、价格统计、库存统计

### 3.2 初始化配置数据
```sql
INSERT INTO `litemall_goods_qa_config` VALUES 
(1, 'llm.api.url', 'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation', '大模型API地址'),
(2, 'llm.api.key', 'your-api-key', '大模型API密钥'),
(3, 'llm.model.name', 'qwen-turbo', '大模型名称'),
(4, 'llm.max.tokens', '2000', '最大token数'),
(5, 'llm.temperature', '0.7', '温度参数'),
(6, 'qa.max.history', '50', '最大历史记录数'),
(7, 'qa.cache.enable', 'true', '是否启用缓存'),
(8, 'qa.cache.ttl', '3600', '缓存过期时间（秒）');
```

## 4. 后端API设计

### 4.1 主要接口

#### 商品问答接口
```java
@RestController
@RequestMapping("/admin/goods-qa")
@Validated
public class AdminGoodsQAController {
    
    /**
     * 发送问题并获取回答
     */
    @PostMapping("/ask")
    public Object askQuestion(@RequestBody GoodsQARequest request) {
        // 实现逻辑
    }
    
    /**
     * 获取问答历史
     */
    @GetMapping("/history")
    public Object getQAHistory(@RequestParam(defaultValue = "1") Integer page,
                              @RequestParam(defaultValue = "10") Integer limit) {
        // 实现逻辑
    }
    
    /**
     * 获取热门问题
     */
    @GetMapping("/hot-questions")
    public Object getHotQuestions() {
        // 实现逻辑
    }
    
    /**
     * 清除问答历史
     */
    @DeleteMapping("/history")
    public Object clearHistory() {
        // 实现逻辑
    }
    
    /**
     * 获取问答配置
     */
    @GetMapping("/config")
    public Object getQAConfig() {
        // 实现逻辑
    }
    
    /**
     * 更新问答配置
     */
    @PutMapping("/config")
    public Object updateQAConfig(@RequestBody GoodsQAConfigRequest request) {
        // 实现逻辑
    }
}
```

### 4.2 请求响应模型

#### 问答请求
```java
public class GoodsQARequest {
    private String question;
    private String context;
    private Boolean includeExplain;
    private Integer maxResults;
    
    // getters and setters
}
```

#### 问答响应
```java
public class GoodsQAResponse {
    private String answer;
    private String questionType;
    private List<GoodsVO> relatedGoods;
    private String executionSql;
    private Long responseTime;
    private String explanation;
    
    // getters and setters
}
```

## 5. 大模型集成设计

### 5.1 提示词设计

#### 系统提示词
```
你是一个商品管理助手，专门帮助管理员查询和分析商品数据。
你可以执行以下类型的查询：

1. 商品信息查询：根据商品名称、编号、价格等条件查询商品
2. 商品推荐：根据销量、评分、库存等条件推荐商品  
3. 数据分析：分析商品销售趋势、库存状况、利润等
4. 统计报表：生成各类商品统计报表

请根据用户的问题，生成相应的SQL查询语句，并以JSON格式返回结果。
返回格式：
{
  "type": "query|recommend|analysis",
  "sql": "生成的SQL语句",
  "explanation": "查询说明",
  "parameters": {}
}
```

#### 查询示例
```
用户问题："查询价格大于100元且库存充足的商品"

大模型返回：
{
  "type": "query",
  "sql": "SELECT * FROM litemall_goods WHERE retail_price > 100 AND is_on_sale = 1 ORDER BY retail_price DESC",
  "explanation": "查询价格大于100元且正在销售的商品",
  "parameters": {}
}
```

### 5.2 API调用封装

#### LLM服务类
```java
@Service
public class LLMService {
    
    @Value("${litemall.llm.api.url}")
    private String apiUrl;
    
    @Value("${litemall.llm.api.key}")
    private String apiKey;
    
    @Value("${litemall.llm.model.name}")
    private String modelName;
    
    /**
     * 调用大模型API解析问题
     */
    public LLMResponse parseQuestion(String question, String context) {
        // 简化：直接基于关键词映射，不调用LLM
        LLMResponse response = new LLMResponse();
        String lowerQuestion = question.toLowerCase();
        
        if (lowerQuestion.contains("价格")) {
            response.setType("query");
            response.setSql("SELECT * FROM litemall_goods WHERE retail_price > 100 AND is_on_sale = 1 ORDER BY retail_price DESC");
            response.setExplanation("查询价格大于100元且正在销售的商品");
        } else if (lowerQuestion.contains("库存")) {
            response.setType("query");
            response.setSql("SELECT g.*, p.number as inventory FROM litemall_goods g LEFT JOIN litemall_goods_product p ON g.id = p.goods_id WHERE g.is_on_sale = 1");
            response.setExplanation("查询商品库存信息");
        } else if (lowerQuestion.contains("统计") || lowerQuestion.contains("总数")) {
            response.setType("statistics");
            response.setSql("SELECT COUNT(*) as total FROM litemall_goods WHERE is_on_sale = 1");
            response.setExplanation("统计在售商品总数");
        } else {
            response.setType("query");
            response.setSql("SELECT * FROM litemall_goods WHERE is_on_sale = 1 LIMIT 10");
            response.setExplanation("默认查询在售商品");
        }
        
        return response;
    }
    
    /**
     * 生成回答
     */
    public String generateAnswer(String question, List<Map<String, Object>> results) {
        if (results.isEmpty()) {
            return "没有找到符合条件的商品。";
        }
        
        StringBuilder answer = new StringBuilder("根据查询结果，");
        
        if (question.contains("价格")) {
            answer.append("价格在指定范围内的商品有").append(results.size()).append("件：");
            for (Map<String, Object> row : results) {
                answer.append(row.get("name")).append("(").append(row.get("retail_price")).append("元) ");
            }
        } else if (question.contains("库存")) {
            answer.append("库存情况如下：");
            for (Map<String, Object> row : results) {
                answer.append(row.get("name")).append("库存").append(row.get("inventory")).append("件 ");
            }
        } else if (question.contains("统计")) {
            Map<String, Object> first = results.get(0);
            answer.append("商品总数为").append(first.get("total")).append("件。");
        } else {
            answer.append("找到").append(results.size()).append("件相关商品。");
        }
        
        return answer.toString();
    }
    
    private String callLLMApi(Map<String, Object> request) {
        // 简化：直接返回模拟响应
        return "{\"type\":\"query\",\"sql\":\"SELECT * FROM litemall_goods WHERE is_on_sale = 1\",\"explanation\":\"查询在售商品\"}";
    }
}
```

## 6. 前端页面设计

### 6.1 页面布局
```
┌─────────────────────────────────────────────────────────────┐
│  商品问答助手                                    [刷新][设置]  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  对话历史区                                          │    │
│  │                                                     │    │
│  │  用户：查询价格大于100元的商品                    │    │
│  │  助手：为您找到以下商品：                          │    │
│  │  ┌─────────────────────────────────────────────┐   │    │
│  │  │ 商品列表展示                                   │   │    │
│  │  │ ┌───┬──────┬──────┬─────┬─────┬────────┐   │   │    │
│  │  │ │ID │ 名称 │ 价格 │ 库存│ 销量│  操作  │   │   │    │
│  │  │ ├───┼──────┼──────┼─────┼─────┼────────┤   │   │    │
│  │  │ │1  │商品A │ 199 │ 100 │ 50 │ [详情] │   │   │    │
│  │  │ │2  │商品B │ 299 │  80 │ 30 │ [详情] │   │   │    │
│  │  │ └───┴──────┴──────┴─────┴─────┴────────┘   │   │    │
│  │  └─────────────────────────────────────────────┘   │    │
│  │                                                     │    │
│  │  用户：推荐一些热销商品                           │    │
│  │  助手：根据销量为您推荐以下商品：                 │    │    │
│  │                                                     │    │
│  │  [SQL: SELECT * FROM goods ORDER BY sales DESC]    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐    │
│  │  输入区域                                            │    │
│  │                                                     │    │
│  │  [输入您的问题...                    ] [发送] [清空]  │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  热门问题：                                                  │
│  [查询库存不足商品] [推荐新品] [分析销售趋势] [价格统计]     │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 组件结构
```javascript
// 商品问答页面组件
export default {
  name: 'GoodsQA',
  components: {
    ChatHistory,
    GoodsTable,
    RecommendationList,
    QuickQuestions
  },
  data() {
    return {
      messages: [],
      currentQuestion: '',
      isLoading: false,
      hotQuestions: []
    }
  },
  methods: {
    async sendQuestion() {
      // 发送问题逻辑
    },
    async loadHistory() {
      // 加载历史记录
    },
    clearChat() {
      // 清空对话
    }
  }
}
```

### 6.3 API调用
```javascript
// 商品问答API
import request from '@/utils/request'

export function askQuestion(data) {
  return request({
    url: '/admin/goods-qa/ask',
    method: 'post',
    data
  })
}

export function getQAHistory(query) {
  return request({
    url: '/admin/goods-qa/history',
    method: 'get',
    params: query
  })
}

export function getHotQuestions() {
  return request({
    url: '/admin/goods-qa/hot-questions',
    method: 'get'
  })
}
```

## 7. 安全与性能优化

### 7.1 安全措施
1. **API限流**: 限制每个用户的请求频率
2. **SQL注入防护**: 严格验证和过滤生成的SQL
3. **敏感数据脱敏**: 对返回的敏感信息进行脱敏处理
4. **权限控制**: 基于角色的访问控制
5. **输入验证**: 严格验证用户输入的问题内容

### 7.2 性能优化
1. **缓存机制**: 缓存常见问题的答案
2. **异步处理**: 复杂查询采用异步处理
3. **分页查询**: 大量数据采用分页返回
4. **索引优化**: 优化数据库查询索引
5. **连接池**: 使用数据库连接池

### 7.3 监控与日志
1. **响应时间监控**: 监控API响应时间
2. **错误率监控**: 监控问答错误率
3. **使用统计**: 统计功能使用情况
4. **审计日志**: 记录所有问答操作

## 8. 部署与配置

### 8.1 配置文件
```yaml
# application.yml
litemall:
  llm:
    api:
      url: ${LLM_API_URL:https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation}
      key: ${LLM_API_KEY:your-api-key}
    model:
      name: ${LLM_MODEL_NAME:qwen-turbo}
      max-tokens: ${LLM_MAX_TOKENS:2000}
      temperature: ${LLM_TEMPERATURE:0.7}
  qa:
    cache:
      enable: true
      ttl: 3600
    max-history: 50
    rate-limit: 100  # 每分钟最多100次请求
```

### 8.2 环境变量
```bash
# 大模型API配置
export LLM_API_URL="https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation"
export LLM_API_KEY="your-actual-api-key"
export LLM_MODEL_NAME="qwen-turbo"
```

## 9. 测试方案

### 9.1 单元测试
1. **LLM服务测试**: 测试大模型API调用
2. **SQL生成测试**: 测试SQL语句生成正确性
3. **数据访问测试**: 测试数据库操作
4. **业务逻辑测试**: 测试问答业务逻辑

### 9.2 集成测试
1. **端到端测试**: 测试完整的问答流程
2. **性能测试**: 测试系统响应时间和并发能力
3. **安全测试**: 测试SQL注入防护和权限控制
4. **异常测试**: 测试异常情况下的系统行为

### 9.3 测试用例示例
```java
@Test
public void testAskQuestion() {
    // 准备测试数据
    GoodsQARequest request = new GoodsQARequest();
    request.setQuestion("查询价格大于100元的商品");
    
    // 执行测试
    GoodsQAResponse response = goodsQAService.askQuestion(request);
    
    // 验证结果
    assertNotNull(response);
    assertEquals("query", response.getQuestionType());
    assertNotNull(response.getAnswer());
    assertTrue(response.getRelatedGoods().size() > 0);
}
```

## 10. 运维与监控

### 10.1 健康检查
```java
@Component
public class GoodsQAHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        try {
            // 检查LLM API连接
            boolean llmHealthy = checkLLMConnection();
            
            // 检查数据库连接
            boolean dbHealthy = checkDatabaseConnection();
            
            if (llmHealthy && dbHealthy) {
                return Health.up()
                    .withDetail("llm", "connected")
                    .withDetail("database", "connected")
                    .build();
            } else {
                return Health.down()
                    .withDetail("llm", llmHealthy ? "connected" : "disconnected")
                    .withDetail("database", dbHealthy ? "connected" : "disconnected")
                    .build();
            }
        } catch (Exception e) {
            return Health.down().withException(e).build();
        }
    }
}
```

### 10.2 指标监控
```java
@Component
public class GoodsQAMetrics {
    
    private final Counter questionCounter;
    private final Timer responseTimer;
    private final Gauge successRateGauge;
    
    public GoodsQAMetrics(MeterRegistry registry) {
        this.questionCounter = Counter.builder("goods_qa_questions_total")
            .description("Total number of questions asked")
            .register(registry);
            
        this.responseTimer = Timer.builder("goods_qa_response_time")
            .description("Response time for questions")
            .register(registry);
            
        this.successRateGauge = Gauge.builder("goods_qa_success_rate")
            .description("Success rate of question answering")
            .register(registry, this, GoodsQAMetrics::calculateSuccessRate);
    }
}
```

## 11. 实施计划

### 11.1 开发阶段
1. **第一阶段** (1-2周):
   - 数据库设计和表结构创建
   - 基础API接口开发
   - 大模型服务集成

2. **第二阶段** (2-3周):
   - 前端页面开发
   - 问答逻辑实现

3. **第三阶段** (1-2周):
   - 性能优化
   - 测试和调试
   - 文档完善

这个设计方案提供了一个完整的基于大模型的商品问答功能实现方案，涵盖了从数据库设计到前端展示，从安全控制到性能优化的各个方面。可以根据实际需求和技术选型进行适当调整。